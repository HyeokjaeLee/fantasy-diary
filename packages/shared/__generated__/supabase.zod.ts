/*
 * This file is auto-generated by scripts/generate-supabase-zod.ts
 * Do not edit manually.
 */

import { z } from "zod";

export const publicEnums = {
  gender: z.enum(["male", "female"]),
} as const;

export const publicTables = {
  /** @table characters: Characters that appear in a novel. */
  characters: {
    Row: z.object({
      id: z.uuid(),
      /** @column characters.novel_id: Parent novel id for this character. */
      novel_id: z.uuid(),
      /** @column characters.name: Character name. */
      name: z.string(),
      /** @column characters.traits: Optional concise traits for the character. */
      traits: z.string().nullable(),
      /** @column characters.personality: Optional personality description for the character. */
      personality: z.string().nullable(),
      /** @column characters.description: Optional longer character description. */
      description: z.string().nullable(),
      /** @column characters.created_at: Character creation timestamp. */
      created_at: z.iso.datetime({ offset: true }),
      /** @column characters.updated_at: Character last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }),
    }).strict(),
    Insert: z.object({
      id: z.uuid().optional(),
      /** @column characters.novel_id: Parent novel id for this character. */
      novel_id: z.uuid(),
      /** @column characters.name: Character name. */
      name: z.string(),
      /** @column characters.traits: Optional concise traits for the character. */
      traits: z.string().nullable().optional(),
      /** @column characters.personality: Optional personality description for the character. */
      personality: z.string().nullable().optional(),
      /** @column characters.description: Optional longer character description. */
      description: z.string().nullable().optional(),
      /** @column characters.created_at: Character creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column characters.updated_at: Character last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
    Update: z.object({
      id: z.uuid().optional(),
      /** @column characters.novel_id: Parent novel id for this character. */
      novel_id: z.uuid().optional(),
      /** @column characters.name: Character name. */
      name: z.string().optional(),
      /** @column characters.traits: Optional concise traits for the character. */
      traits: z.string().nullable().optional(),
      /** @column characters.personality: Optional personality description for the character. */
      personality: z.string().nullable().optional(),
      /** @column characters.description: Optional longer character description. */
      description: z.string().nullable().optional(),
      /** @column characters.created_at: Character creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column characters.updated_at: Character last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
  },
  /** @table episode_characters: Join table linking episodes and characters. */
  episode_characters: {
    Row: z.object({
      id: z.uuid(),
      /** @column episode_characters.episode_id: Episode id reference. */
      episode_id: z.uuid(),
      /** @column episode_characters.character_id: Character id reference. */
      character_id: z.uuid(),
      /** @column episode_characters.created_at: Join creation timestamp. */
      created_at: z.iso.datetime({ offset: true }),
    }).strict(),
    Insert: z.object({
      id: z.uuid().optional(),
      /** @column episode_characters.episode_id: Episode id reference. */
      episode_id: z.uuid(),
      /** @column episode_characters.character_id: Character id reference. */
      character_id: z.uuid(),
      /** @column episode_characters.created_at: Join creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
    Update: z.object({
      id: z.uuid().optional(),
      /** @column episode_characters.episode_id: Episode id reference. */
      episode_id: z.uuid().optional(),
      /** @column episode_characters.character_id: Character id reference. */
      character_id: z.uuid().optional(),
      /** @column episode_characters.created_at: Join creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
  },
  /** @table episode_locations: Join table linking episodes and locations. */
  episode_locations: {
    Row: z.object({
      id: z.uuid(),
      /** @column episode_locations.episode_id: Episode id reference. */
      episode_id: z.uuid(),
      /** @column episode_locations.location_id: Location id reference. */
      location_id: z.uuid(),
      /** @column episode_locations.created_at: Join creation timestamp. */
      created_at: z.iso.datetime({ offset: true }),
    }).strict(),
    Insert: z.object({
      id: z.uuid().optional(),
      /** @column episode_locations.episode_id: Episode id reference. */
      episode_id: z.uuid(),
      /** @column episode_locations.location_id: Location id reference. */
      location_id: z.uuid(),
      /** @column episode_locations.created_at: Join creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
    Update: z.object({
      id: z.uuid().optional(),
      /** @column episode_locations.episode_id: Episode id reference. */
      episode_id: z.uuid().optional(),
      /** @column episode_locations.location_id: Location id reference. */
      location_id: z.uuid().optional(),
      /** @column episode_locations.created_at: Join creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
  },
  /** @table episodes: Individual episodes for a novel series. */
  episodes: {
    Row: z.object({
      id: z.uuid(),
      /** @column episodes.novel_id: Parent novel id for this episode. */
      novel_id: z.uuid(),
      /** @column episodes.episode_number: 1-based sequential episode number within a novel. */
      episode_number: z.int(),
      /** @column episodes.body: Episode body text. */
      body: z.string(),
      /** @column episodes.embedding: Optional embedding vector for the episode body as JSON array. */
      embedding: z.unknown().nullable(),
      /** @column episodes.embedding_model: Embedding model identifier used to generate embedding. */
      embedding_model: z.string().nullable(),
      /** @column episodes.created_at: Episode creation timestamp. */
      created_at: z.iso.datetime({ offset: true }),
      /** @column episodes.updated_at: Episode last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }),
    }).strict(),
    Insert: z.object({
      id: z.uuid().optional(),
      /** @column episodes.novel_id: Parent novel id for this episode. */
      novel_id: z.uuid(),
      /** @column episodes.episode_number: 1-based sequential episode number within a novel. */
      episode_number: z.int(),
      /** @column episodes.body: Episode body text. */
      body: z.string(),
      /** @column episodes.embedding: Optional embedding vector for the episode body as JSON array. */
      embedding: z.unknown().nullable().optional(),
      /** @column episodes.embedding_model: Embedding model identifier used to generate embedding. */
      embedding_model: z.string().nullable().optional(),
      /** @column episodes.created_at: Episode creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column episodes.updated_at: Episode last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
    Update: z.object({
      id: z.uuid().optional(),
      /** @column episodes.novel_id: Parent novel id for this episode. */
      novel_id: z.uuid().optional(),
      /** @column episodes.episode_number: 1-based sequential episode number within a novel. */
      episode_number: z.int().optional(),
      /** @column episodes.body: Episode body text. */
      body: z.string().optional(),
      /** @column episodes.embedding: Optional embedding vector for the episode body as JSON array. */
      embedding: z.unknown().nullable().optional(),
      /** @column episodes.embedding_model: Embedding model identifier used to generate embedding. */
      embedding_model: z.string().nullable().optional(),
      /** @column episodes.created_at: Episode creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column episodes.updated_at: Episode last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
  },
  /** @table locations: Locations that appear in a novel. */
  locations: {
    Row: z.object({
      id: z.uuid(),
      /** @column locations.novel_id: Parent novel id for this location. */
      novel_id: z.uuid(),
      /** @column locations.name: Location name. */
      name: z.string(),
      /** @column locations.description: Optional location description. */
      description: z.string().nullable(),
      /** @column locations.created_at: Location creation timestamp. */
      created_at: z.iso.datetime({ offset: true }),
      /** @column locations.updated_at: Location last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }),
    }).strict(),
    Insert: z.object({
      id: z.uuid().optional(),
      /** @column locations.novel_id: Parent novel id for this location. */
      novel_id: z.uuid(),
      /** @column locations.name: Location name. */
      name: z.string(),
      /** @column locations.description: Optional location description. */
      description: z.string().nullable().optional(),
      /** @column locations.created_at: Location creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column locations.updated_at: Location last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
    Update: z.object({
      id: z.uuid().optional(),
      /** @column locations.novel_id: Parent novel id for this location. */
      novel_id: z.uuid().optional(),
      /** @column locations.name: Location name. */
      name: z.string().optional(),
      /** @column locations.description: Optional location description. */
      description: z.string().nullable().optional(),
      /** @column locations.created_at: Location creation timestamp. */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column locations.updated_at: Location last update timestamp. */
      updated_at: z.iso.datetime({ offset: true }).optional(),
    }).strict(),
  },
  /** @table novels: 소설(시리즈) 메타데이터 루트 엔티티 */
  novels: {
    Row: z.object({
      /** @column novels.id: 소설 고유 ID (UUID) */
      id: z.uuid(),
      /** @column novels.title: 소설 제목 */
      title: z.string(),
      /** @column novels.genre: 장르(자유 텍스트) */
      genre: z.string(),
      /** @column novels.status: 소설 상태(기본값 'active') */
      status: z.string(),
      /** @column novels.created_at: 소설 생성 시각 */
      created_at: z.iso.datetime({ offset: true }),
      /** @column novels.story_bible: 소설 세계관, 설정, 톤앤매너 등 작품 전반의 바이블 */
      story_bible: z.string(),
      /** @column novels.append_prompt: Writer Agent 실행 시 추가로 전달할 프롬프트 */
      append_prompt: z.string().nullable(),
      /** @column novels.updated_at: 소설 정보 마지막 수정 시각 */
      updated_at: z.iso.datetime({ offset: true }).nullable(),
      /** @column novels.initial_seed: 1화 생성 시 사용할 초기 시드 (선택사항) */
      initial_seed: z.string().nullable(),
      /** @column novels.initial_plot_seeds: 초기 플롯 시드 목록 (JSON 배열 형식의 문자열) */
      initial_plot_seeds: z.string().nullable(),
      /** @column novels.plot_seeds_resolved: 초기 플롯 시드가 모두 회수되었는지 여부 */
      plot_seeds_resolved: z.boolean().nullable(),
    }).strict(),
    Insert: z.object({
      /** @column novels.id: 소설 고유 ID (UUID) */
      id: z.uuid().optional(),
      /** @column novels.title: 소설 제목 */
      title: z.string(),
      /** @column novels.genre: 장르(자유 텍스트) */
      genre: z.string(),
      /** @column novels.status: 소설 상태(기본값 'active') */
      status: z.string().optional(),
      /** @column novels.created_at: 소설 생성 시각 */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column novels.story_bible: 소설 세계관, 설정, 톤앤매너 등 작품 전반의 바이블 */
      story_bible: z.string().optional(),
      /** @column novels.append_prompt: Writer Agent 실행 시 추가로 전달할 프롬프트 */
      append_prompt: z.string().nullable().optional(),
      /** @column novels.updated_at: 소설 정보 마지막 수정 시각 */
      updated_at: z.iso.datetime({ offset: true }).nullable().optional(),
      /** @column novels.initial_seed: 1화 생성 시 사용할 초기 시드 (선택사항) */
      initial_seed: z.string().nullable().optional(),
      /** @column novels.initial_plot_seeds: 초기 플롯 시드 목록 (JSON 배열 형식의 문자열) */
      initial_plot_seeds: z.string().nullable().optional(),
      /** @column novels.plot_seeds_resolved: 초기 플롯 시드가 모두 회수되었는지 여부 */
      plot_seeds_resolved: z.boolean().nullable().optional(),
    }).strict(),
    Update: z.object({
      /** @column novels.id: 소설 고유 ID (UUID) */
      id: z.uuid().optional(),
      /** @column novels.title: 소설 제목 */
      title: z.string().optional(),
      /** @column novels.genre: 장르(자유 텍스트) */
      genre: z.string().optional(),
      /** @column novels.status: 소설 상태(기본값 'active') */
      status: z.string().optional(),
      /** @column novels.created_at: 소설 생성 시각 */
      created_at: z.iso.datetime({ offset: true }).optional(),
      /** @column novels.story_bible: 소설 세계관, 설정, 톤앤매너 등 작품 전반의 바이블 */
      story_bible: z.string().optional(),
      /** @column novels.append_prompt: Writer Agent 실행 시 추가로 전달할 프롬프트 */
      append_prompt: z.string().nullable().optional(),
      /** @column novels.updated_at: 소설 정보 마지막 수정 시각 */
      updated_at: z.iso.datetime({ offset: true }).nullable().optional(),
      /** @column novels.initial_seed: 1화 생성 시 사용할 초기 시드 (선택사항) */
      initial_seed: z.string().nullable().optional(),
      /** @column novels.initial_plot_seeds: 초기 플롯 시드 목록 (JSON 배열 형식의 문자열) */
      initial_plot_seeds: z.string().nullable().optional(),
      /** @column novels.plot_seeds_resolved: 초기 플롯 시드가 모두 회수되었는지 여부 */
      plot_seeds_resolved: z.boolean().nullable().optional(),
    }).strict(),
  },
} as const;

export const SupabaseZod = {
  public: {
    Enums: publicEnums,
    Tables: publicTables,
  },
} as const;